"""
Module used internally by Pyto for importing C extension.
"""

import sys
import importlib
import traceback
import os
import warnings

class __UpgradeException__(Exception):
    pass

if "widget" not in os.environ:
    from sharing import open_url
    import urllib.parse
    from pyto import Python, __Class__
    from rubicon.objc import ObjCClass
    
    ExtensionsInitializer = ObjCClass("ExtensionsInitializer")

    def have_internet():
        return __Class__("InternetConnection").isReachable

    c = ExtensionsInitializer.alloc().init()

    def update_mods():
        # Builtins
        def add(mod):
            if str(mod) in sys.builtin_module_names:
                return
            
            sys.builtin_module_names += (str(mod),)
            Python.shared.importedModules.addObject(mod)

        try:
            for mod in Python.shared.modules:
                add(mod)
        except TypeError:
            for mod in Python.shared.modules():
                add(mod)

# MARK: - Pillow

class PillowImporter(object):
    """
    Meta path for importing Pillow to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('PIL._imaging', 'PIL._imagingft', 'PIL._imagingmath', 'PIL._imagingmorph', 'PIL._imagingtk'):
            return self
        
        if fullname == 'PIL' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        
        if not "widget" in os.environ:
            update_mods()
    
        f = fullname
        if f != 'PIL':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'PIL':
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('Pillow', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

if "widget" not in os.environ:
    def report_error(module, trace_back, e):
        """
        Sends an E-mail reporting error.
        
        Args:
            module: The module's that cannot be imported name.
            trace_back: Traceback as string.
        """

        if type(e) is ModuleNotFoundError:
            return

        try:
            from pyto_ui import Alert
            alert = Alert(title=module, message="An error occurred while importing "+module+".\n\nDo you want to report error to the developer?")
            alert.add_action("Report")
            alert.add_cancel_action("Cancel")

            if alert.show() == "Report":
                open_url("mailto:support@pyto.app?subject="+module+"%20Importing%20Error&body="+urllib.parse.quote(trace_back))
        except ImportError:
            pass

    # MARK: - NumPy

    class NumpyImporter(object):
        """
        Meta path for importing NumPy to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('numpy.random._bit_generator', 'numpy.random._bounded_integers', 'numpy.random._common', 'numpy.random._generator', 'numpy.random._mt19937', 'numpy.core._multiarray_tests', 'numpy.core._operand_flag_tests', 'numpy.random._pcg64', 'numpy.random._philox', 'numpy.fft._pocketfft_internal', 'numpy.core._rational_tests', 'numpy.random._sfc64', 'numpy.core._struct_ufunc_tests', 'numpy.linalg._umath_linalg', 'numpy.core._umath_tests', 'numpy.linalg.lapack_lite', 'numpy.random.mtrand', 'numpy.core._multiarray_umath'):
                return self
            
            if fullname == 'numpy' and not self.__is_importing__:
                return self
            
            return
        
        def load_module(self, fullname):
            f = fullname
            if f != 'numpy':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'numpy' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        pass
                    except SystemExit:
                        pass
                    except Exception as e:
                        
                        report_error('Numpy', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False

                return mod
            
            return mod

    # MARK: - Matplotlib

    class MatplotlibImporter(object):
        """
        Meta path for importing Matplotlib to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('matplotlib.backends._backend_agg', 'matplotlib._path', 'matplotlib._image', 'matplotlib._png', 'matplotlib.ft2font', 'matplotlib._contour', 'matplotlib._qhull', 'matplotlib._tri', 'matplotlib.ttconv'):
                return self
            
            if fullname == 'matplotlib' and not self.__is_importing__:
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_matplotlib()
            update_mods()
        
            f = fullname
            if f != 'matplotlib':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'matplotlib' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Matplotlib', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            
            return mod

    # MARK: - Pandas

    class PandasImporter(object):
        """
        Meta path for importing Pandas to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'pandas' and not self.__is_importing__:
                return self
            
            if fullname in ('pandas.io.sas._sas', 'pandas._libs.window.aggregations', 'pandas._libs.algos', 'pandas._libs.tslibs.c_timestamp', 'pandas._libs.tslibs.ccalendar', 'pandas._libs.tslibs.conversion', 'pandas._libs.tslibs.fields', 'pandas._libs.tslibs.frequencies', 'pandas._libs.groupby', 'pandas._libs.hashing', 'pandas._libs.hashtable', 'pandas._libs.index', 'pandas._libs.window.indexers', 'pandas._libs.indexing', 'pandas._libs.internals', 'pandas._libs.interval', 'pandas._libs.join', 'pandas._libs.json', 'pandas._libs.lib', 'pandas._libs.missing', 'pandas._libs.tslibs.nattype', 'pandas._libs.tslibs.np_datetime', 'pandas._libs.tslibs.offsets', 'pandas._libs.ops_dispatch', 'pandas._libs.ops', 'pandas._libs.parsers', 'pandas._libs.tslibs.parsing', 'pandas._libs.tslibs.period', 'pandas._libs.properties', 'pandas._libs.reduction', 'pandas._libs.reshape', 'pandas._libs.tslibs.resolution', 'pandas._libs.sparse', 'pandas._libs.tslibs.strptime', 'pandas._libs.testing', 'pandas._libs.tslibs.timedeltas', 'pandas._libs.tslibs.timestamps', 'pandas._libs.tslibs.timezones', 'pandas._libs.tslib', 'pandas._libs.tslibs.tzconversion', 'pandas._libs.writers'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_pandas()
            update_mods()
        
            f = fullname
            if f != 'pandas':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'pandas' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Pandas', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            
            return mod

    # MARK: - Biopython

    class BiopythonImporter(object):
        """
        Meta path for importing Biopython to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('Bio.Align._aligners', 'Bio.KDTree._CKDTree', 'Bio.Cluster._cluster', 'Bio.motifs._pwm', 'Bio.Nexus.cnexus', 'Bio.cpairwise2', 'Bio.PDB.kdtrees', 'Bio.PDB.QCPSuperimposer.qcprotmodule', 'Bio.trie'):
                return self
            
            if fullname == 'Bio' and not self.__is_importing__:
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_biopython()
            update_mods()
        
            f = fullname
            if f != 'Bio':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'Bio' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        pass
                    except SystemExit:
                        pass
                    except Exception as e:
                        
                        report_error('Biopython', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False

                return mod
            
            return mod

    # MARK: - LXML

    class LXMLImporter(object):
        """
        Meta path for importing LXML to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'lxml' and not self.__is_importing__:
                return self
                    
            if fullname in ('lxml._elementpath', 'lxml.builder', 'lxml.etree', 'lxml.html.clean', 'lxml.html.diff', 'lxml.objectifiy', 'lxml.sax'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_lxml()
            update_mods()
        
            f = fullname
            if f != 'lxml':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = None
                        try:
                            mod = importlib.__import__(f)
                        except ImportError:
                            sys.builtin_module_names += (f,)
                            mod = importlib.__import__(f)
                        
                        sys.modules[fullname] = mod
                
                if fullname != 'lxml' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('LXML', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            
            return mod

    # MARK: - SciPy

    # Thanks to @goodclass for the amazing work!!!!!!

    class ScipyImporter(object):
        """
        Meta path for importing Scipy to be added to `sys.meta_path`.
        """

        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('scipy.odr.__odrpack', 'scipy.cluster._optimal_leaf_ordering', 'scipy.cluster._vq', 'scipy.cluster._hierarchy', 'scipy.ndimage._ni_label', 'scipy.ndimage._nd_image', 'scipy.ndimage._ctest_oldapi', 'scipy.ndimage._cytest', 'scipy.ndimage._ctest', 'scipy.linalg._solve_toeplitz', 'scipy.linalg._flinalg', 'scipy.linalg._decomp_update', 'scipy.linalg._interpolative', 'scipy.linalg.cython_blas', 'scipy.linalg._flapack', 'scipy.linalg._fblas', 'scipy.linalg.cython_lapack', 'scipy.optimize._zeros', 'scipy.optimize._minpack', 'scipy.optimize._trlib._trlib', 'scipy.optimize._slsqp', 'scipy.optimize._group_columns', 'scipy.optimize._cobyla', 'scipy.optimize._lsq.givens_elimination', 'scipy.optimize.minpack2', 'scipy.optimize._lbfgsb', 'scipy.optimize._nnls', 'scipy.optimize.moduleTNC', 'scipy.integrate._odepack', 'scipy.integrate._test_multivariate', 'scipy.integrate._test_odeint_banded', 'scipy.integrate.lsoda', 'scipy.integrate.vode', 'scipy.integrate._quadpack', 'scipy.integrate._dop', 'scipy.io.matlab.streams', 'scipy.io.matlab.mio5_utils', 'scipy.io.matlab.mio_utils', 'scipy.io._test_fortran', 'scipy._lib._fpumode', 'scipy._lib._ccallback_c', 'scipy._lib.messagestream', 'scipy._lib._test_ccallback', 'scipy.special._comb', 'scipy.special.cython_special', 'scipy.special._ufuncs', 'scipy.special._test_round', 'scipy.special.specfun', 'scipy.special._ufuncs_cxx', 'scipy.special._ellip_harm_2', 'scipy.fftpack._fftpack', 'scipy.fftpack.convolve', 'scipy.interpolate.dfitpack', 'scipy.interpolate._bspl', 'scipy.interpolate._ppoly', 'scipy.interpolate.interpnd', 'scipy.interpolate._fitpack', 'scipy.interpolate._interpolate', 'scipy.sparse.linalg.isolve._iterative', 'scipy.sparse.linalg.eigen.arpack._arpack', 'scipy.sparse.linalg.dsolve._superlu', 'scipy.sparse._sparsetools', 'scipy.sparse.csgraph._reordering', 'scipy.sparse.csgraph._min_spanning_tree', 'scipy.sparse.csgraph._tools', 'scipy.sparse.csgraph._traversal', 'scipy.sparse.csgraph._shortest_path', 'scipy.sparse._csparsetools', 'scipy.spatial.qhull', 'scipy.spatial._voronoi', 'scipy.spatial._hausdorff', 'scipy.spatial.ckdtree', 'scipy.spatial._distance_wrap', 'scipy.signal._upfirdn_apply', 'scipy.signal.sigtools', 'scipy.signal._peak_finding_utils', 'scipy.signal._spectral', 'scipy.signal.spline', 'scipy.signal._max_len_seq_inner', 'scipy.stats.statlib', 'scipy.stats.mvn', 'scipy.stats._stats'):
                return self
            
            if fullname == 'scipy' and not self.__is_importing__:
                return self
            return
        
        def load_module(self, fullname):
        
            c.initialize_scipy()
            update_mods()
        
            f = fullname
            if f != 'scipy':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = None
                        try:
                            mod = importlib.__import__(f)
                        except ImportError:
                            sys.builtin_module_names += (f,)
                            mod = importlib.__import__(f)
                        
                        sys.modules[fullname] = mod
                
                if fullname != 'scipy' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        pass
                    except SystemExit:
                        pass
                    except Exception as e:
                        
                        report_error('scipy', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - SkLearn

    class SkLearnImporter(object):
        """
        Meta path for importing SkLearn to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('sklearn.neighbors._ball_tree', 'sklearn.manifold._barnes_hut_tsne', 'sklearn.ensemble._hist_gradient_boosting._binning', 'sklearn.linear_model._cd_fast', 'sklearn.decomposition._cdnmf_fast', 'sklearn.__check_build._check_build', 'sklearn.tree._criterion', 'sklearn.preprocessing._csr_polynomial_expansion', 'sklearn.utils._cython_blas', 'sklearn.cluster._dbscan_inner', 'sklearn.neighbors._dist_metrics', 'sklearn.metrics.cluster._expected_mutual_info_fast', 'sklearn.utils._fast_dict', 'sklearn.ensemble._hist_gradient_boosting._gradient_boosting', 'sklearn.ensemble._gradient_boosting', 'sklearn.feature_extraction._hashing_fast', 'sklearn.cluster._hierarchical_fast', 'sklearn._isotonic', 'sklearn.cluster._k_means_elkan', 'sklearn.cluster._k_means_fast', 'sklearn.neighbors._kd_tree', 'sklearn.svm._liblinear', 'sklearn.svm._libsvm_sparse', 'sklearn.svm._libsvm', 'sklearn.utils._logistic_sigmoid', 'sklearn.ensemble._hist_gradient_boosting._loss', 'sklearn.decomposition._online_lda_fast', 'sklearn.utils._openmp_helpers', 'sklearn.metrics._pairwise_fast', 'sklearn.ensemble._hist_gradient_boosting._predictor', 'sklearn.neighbors._quad_tree', 'sklearn.utils._random', 'sklearn.linear_model._sag_fast', 'sklearn.utils._seq_dataset', 'sklearn.linear_model._sgd_fast', 'sklearn.tree._splitter', 'sklearn.datasets._svmlight_format_fast', 'sklearn.tree._tree', 'sklearn.neighbors._typedefs', 'sklearn.tree._utils', 'sklearn.manifold._utils', 'sklearn.utils._weight_vector', 'sklearn.utils.arrayfuncs', 'sklearn.ensemble._hist_gradient_boosting.common', 'sklearn.utils.graph_shortest_path', 'sklearn.ensemble._hist_gradient_boosting.histogram', 'sklearn.utils.murmurhash', 'sklearn.utils.sparsefuncs_fast', 'sklearn.ensemble._hist_gradient_boosting.splitting', 'sklearn.ensemble._hist_gradient_boosting.utils'):
                return self
            
            if fullname == 'sklearn' and not self.__is_importing__:
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_sklearn()
            update_mods()
        
            f = fullname
            if f != 'sklearn':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'sklearn' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        pass
                    except SystemExit:
                        pass
                    except Exception as e:
                        
                        report_error('SciKit-Learn', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - SKImage

    class SkImageImporter(object):
        """
        Meta path for importing SkImage to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'skimage' and not self.__is_importing__:
                return self
            
            if fullname in ('skimage.filters._ctmf', 'skimage.filters.rank.bilateral_cy', 'skimage.filters.rank.generic_cy', 'skimage.filters.rank.percentile_cy', 'skimage.filters.rank.core_cy', 'skimage.restoration._denoise_cy', 'skimage.restoration._unwrap_1d', 'skimage.restoration._unwrap_2d', 'skimage.restoration._nl_means_denoising', 'skimage.restoration._unwrap_3d', 'skimage.segmentation._felzenszwalb_cy', 'skimage.segmentation._slic', 'skimage.segmentation._quickshift_cy', 'skimage.io._plugins._colormixer', 'skimage.io._plugins._histograms', 'skimage.graph._mcp', 'skimage.graph._spath', 'skimage.graph.heap', 'skimage.measure._ccomp', 'skimage.measure._pnpoly', 'skimage.measure._marching_cubes_classic_cy', 'skimage.measure._marching_cubes_lewiner_cy', 'skimage.measure._find_contours_cy', 'skimage.measure._moments_cy', 'skimage._shared.transform', 'skimage._shared.interpolation', 'skimage._shared.geometry', 'skimage.morphology._extrema_cy', 'skimage.morphology._skeletonize_3d_cy', 'skimage.morphology._convex_hull', 'skimage.morphology._greyreconstruct', 'skimage.morphology._skeletonize_cy', 'skimage.morphology._watershed', 'skimage.feature._texture', 'skimage.feature.orb_cy', 'skimage.feature._hoghistogram', 'skimage.feature.brief_cy', 'skimage.feature.censure_cy', 'skimage.feature._haar', 'skimage.feature._hessian_det_appx', 'skimage.feature.corner_cy', 'skimage.external.tifffile._tifffile', 'skimage.transform._warps_cy', 'skimage.transform._hough_transform', 'skimage.transform._radon_transform', 'skimage.transform._seam_carving', 'skimage.draw._draw', 'skimage.future.graph._ncut_cy', 'skimage.filters._multiotsu', 'skimage.morphology._flood_fill_cy', 'skimage.morphology._max_tree', 'skimage.feature._cascade'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_skimage()
            update_mods()
        
            f = fullname
            if f != 'skimage':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'skimage' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('SciKit-Image', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Pywt

    class PywtImporter(object):
        """
        Meta path for importing Pywt to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'pywt' and not self.__is_importing__:
                return self
            
            if fullname in ('pywt._extensions._cwt', 'pywt._extensions._dwt', 'pywt._extensions._swt', 'pywt._extensions._pywt'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_pywt()
            update_mods()
        
            f = fullname
            if f != 'pywt':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'pywt' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Pywt', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Nacl

    class NaclImporter(object):
        """
        Meta path for importing Nacl to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'nacl' and not self.__is_importing__:
                return self
            
            if fullname in ('nacl._sodium', 'nacl._sodium'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_nacl()
            update_mods()
        
            f = fullname
            if f != 'nacl':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'nacl' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('PyNaCl', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Cryptography

    class CryptographyImporter(object):
        """
        Meta path for importing Cryptography to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'cryptography' and not self.__is_importing__:
                return self
            
            if fullname in ('cryptography.hazmat.bindings._constant_time', 'cryptography.hazmat.bindings._padding', 'cryptography.hazmat.bindings._openssl'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_cffi()
            update_mods()
        
            f = fullname
            if f != 'cryptography':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'cryptography' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Cryptography', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Bcrypt

    class BcryptImporter(object):
        """
        Meta path for importing Bcrypt to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'bcrypt' and not self.__is_importing__:
                return self
            
            if fullname in ('bcrypt._bcrypt', 'bcrypt._bcrypt'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_bcrypt()
            update_mods()
        
            f = fullname
            if f != 'bcrypt':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'bcrypt' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Bcrypt', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Statsmodels

    class StatsmodelsImporter(object):
        """
        Meta path for importing Statsmodels to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'statsmodels' and not self.__is_importing__:
                return self
            
            if fullname in ('statsmodels.tsa.statespace._smoothers._alternative', 'statsmodels.tsa.innovations._arma_innovations', 'statsmodels.tsa.statespace._smoothers._classical', 'statsmodels.tsa._exponential_smoothers', 'statsmodels.tsa.statespace._filters._conventional', 'statsmodels.tsa.statespace._filters._univariate_diffuse', 'statsmodels.tsa.statespace._filters._univariate', 'statsmodels.tsa.regime_switching._hamilton_filter', 'statsmodels.tsa.statespace._initialization', 'statsmodels.tsa._innovations', 'statsmodels.tsa.statespace._filters._inversions', 'statsmodels.tsa.statespace._kalman_filter', 'statsmodels.tsa.statespace._kalman_smoother', 'statsmodels.tsa.regime_switching._kim_smoother', 'statsmodels.tsa.statespace._representation', 'statsmodels.tsa.statespace._simulation_smoother', 'statsmodels.tsa.statespace._smoothers._conventional', 'statsmodels.tsa.statespace._smoothers._univariate_diffuse', 'statsmodels.tsa.statespace._smoothers._univariate', 'statsmodels.nonparametric._smoothers_lowess', 'statsmodels.tsa._stl', 'statsmodels.tsa.statespace._tools', 'statsmodels.tsa.kalmanf.kalman_loglike', 'statsmodels.nonparametric.linbin',):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_statsmodels()
            update_mods()
        
            f = fullname
            if f != 'statsmodels':
                f = '__' + fullname.replace('.', '_')
                
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'statsmodels' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Statsmodels', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Zmq

    class ZmqImporter(object):
        """
        Meta path for importing Zmq to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'zmq' and not self.__is_importing__:
                return self
            
            if fullname in ('zmq.backend.cython._device', 'zmq.backend.cython._poll', 'zmq.backend.cython._proxy_steerable', 'zmq.backend.cython._version', 'zmq.backend.cython.constants', 'zmq.backend.cython.context', 'zmq.backend.cython.error', 'zmq.backend.cython.message', 'zmq.devices.monitoredqueue', 'zmq.backend.cython.socket', 'zmq.backend.cython.utils'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_zmq()
            update_mods()
        
            f = fullname
            if f != 'zmq':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'zmq' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Zmq', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Regex

    class RegexImporter(object):
        """
        Meta path for importing Regex to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'regex' and not self.__is_importing__:
                return self
            
            if fullname == 'regex._regex':
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_regex()
            update_mods()
        
            f = fullname
            if f != 'regex':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'regex' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Regex', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Gensim

    class GensimImporter(object):
        """
        Meta path for importing Gensim to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if fullname == 'gensim' and not self.__is_importing__:
                return self
            
            if fullname in ('gensim._matutils', 'gensim.corpora._mmreader', 'gensim.models._utils_any2vec', 'gensim.models.doc2vec_corpusfile', 'gensim.models.doc2vec_inner', 'gensim.models.fasttext_corpusfile', 'gensim.models.fasttext_inner', 'gensim.models.nmf_pgd', 'gensim.models.word2vec_corpusfile', 'gensim.models.word2vec_inner'):
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_gensim()
            update_mods()
        
            f = fullname
            if f != 'gensim':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        mod = importlib.__import__(f)
                        sys.modules[fullname] = mod
                
                if fullname != 'gensim' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        return
                    except SystemExit:
                        return
                    except Exception as e:
                        
                        report_error('Gensim', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False
                
                return mod
            return mod

    # MARK: - Astropy

    class AstropyImporter(object):
        """
        Meta path for importing Astropy to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        __imported_cparser__ = False
        
        def find_module(self, fullname, mpath=None):
            if fullname in ('astropy.table._column_mixins', 'astropy.utils._compiler', 'astropy.convolution._convolve', 'astropy.timeseries.periodograms.bls._impl', 'astropy.utils.xml._iterparser', 'astropy.table._np_utils', 'astropy.modeling._projections', 'astropy.stats._stats', 'astropy.wcs._wcs', 'astropy.compiler_version', 'astropy.io.ascii.cparser', 'astropy.timeseries.periodograms.lombscargle.implementations.cython_impl', 'astropy.io.fits._utils', 'astropy.cosmology.scalar_inv_efuncs', 'astropy.io.votable.tablewriter', 'astropy._erfa.ufunc', 'astropy.io.fits.compression',):
                return self
            
            if fullname == 'astropy' and not self.__is_importing__:
                return self
            
            return
        
        def load_module(self, fullname):
        
            c.initialize_astropy()
            update_mods()
        
            f = fullname.replace("fits__utils", "_utils")
            if f != 'astropy':
                f = '__' + fullname.replace('.', '_')
            mod = sys.modules.get(f)
            if mod is None:
                def importMod():
                    with warnings.catch_warnings(record=True) as w:
                        try:
                            mod = importlib.__import__(f)
                        except ImportError:
                            try: # Relative import on Cython mods
                                import imp
                                name_parts = fullname.split(".")
                                path = imp.find_module(name_parts[0])[1]
                                path += "/"+("/".join(name_parts[:-1]))
                                mod = importlib.__import__(f, locals={"__file__":path})
                            except ImportError:
                                mod = importlib.__import__(f)
                        
                        sys.modules[fullname] = mod
                
                if fullname != 'astropy' or "widget" in os.environ:
                    importMod()
                else:
                    try:
                        self.__is_importing__ = True
                        importMod()
                        self.__is_importing__ = False
                    except KeyboardInterrupt:
                        pass
                    except SystemExit:
                        pass
                    except Exception as e:
                        
                        report_error('Astropy', traceback.format_exc(), e)
                        raise
                    finally:
                        self.__is_importing__ = False

                return mod
            
            return mod

    # MARK: - Downloadable Content

    class DownloadableImporter(object):
        """
        Meta path for importing downloadable libraries to be added to `sys.meta_path`.
        """
        
        __is_importing__ = False
        
        def find_module(self, fullname, mpath=None):
            
            if self.__is_importing__:
                return
            
            libname = fullname.split(".")[0]
            if libname in ('imageio', 'networkx', 'dask', 'jmespath', 'joblib', 'smart_open', 'boto', 'boto3', 'botocore', 'pywt', 'bcrypt', 'Bio', 'cryptography',  'cv2', 'gensim', 'lxml', 'matplotlib', 'nacl', 'numpy', 'pandas', 'regex', 'scipy', 'skimage', 'sklearn', 'statsmodels', 'zmq', 'astropy'):
                return self
            
            return
        
        def is_package(self, i_dont_know_what_goes_here):
            return False
        
        def load_module(self, fullname):
            self.__is_importing__ = True
            
            try:
                mod = importlib.__import__(fullname)
                self.__is_importing__ = False
                return mod
            except ModuleNotFoundError:
            
                if not have_internet():
                    msg = f"The internet connection seems to be offline and the imported library {fullname.split('.')[0].lower()} is not downloaded. Make sure you are connected to internet. Once downloaded, the library will be available offline."
                    raise ImportError(msg)
            
                paths = Python.shared.access(fullname.split(".")[0].lower())
                for path in paths:
                    if str(path) == "error":
                        self.__is_importing__ = False
                        
                        if len(paths) == 3 and str(paths[2]) == "upgrade":
                            import threading
                            from pyto import PyOutputHelper
                            
                            try:
                                price = str(Python.shared.environment["UPGRADE_PRICE"])
                            except KeyError:
                                price = "5.99$"
                            
                            try:
                                script_path = threading.current_thread().script_path
                            except AttributeError:
                                script_path = None
                                
                            PyOutputHelper.printLink(f"Upgrade {price}\n", url="pyto://upgrade", script=script_path)
                            
                            raise __UpgradeException__(str(paths[1]))
                        
                        raise ImportError(str(paths[1]))
                    if not str(path) in sys.path:
                        sys.path.insert(0, str(path))
                
                try:
                    return importlib.__import__(fullname)
                finally:
                    self.__is_importing__ = False
            
            self.__is_importing__ = False

    # MARK: - All

    __all__ = ['DownloadableImporter', 'NumpyImporter', 'MatplotlibImporter', 'PandasImporter', 'PillowImporter', 'BiopythonImporter', 'LXMLImporter', 'ScipyImporter', 'SkLearnImporter', 'SkImageImporter', 'PywtImporter', 'NaclImporter', 'CryptographyImporter', 'BcryptImporter', 'StatsmodelsImporter', 'ZmqImporter', 'RegexImporter', 'GensimImporter', 'AstropyImporter']

else:
    
    __all__ = ['PillowImporter']
